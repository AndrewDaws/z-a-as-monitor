#!/usr/bin/env zsh
# -*- mode: sh; sh-indentation: 4; indent-tabs-mode: nil; sh-basic-offset: 4; -*-

# Copyright (c) 2019 Sebastian Gniazdowski

# Set the base and typically useful options
emulate -LR zsh
setopt extendedglob warncreateglobal typesetsilent noshortloops rcquotes

[[ ${ZPLG_ICE[as]} != track* && ${ZPLG_ICE[.track]} != track* ]] && return 0
[[ $1 = plugin ]] && {
    print -P -- "${ZPLGM[col-pre]}as-track annex: %F{160}ERROR: as'${ZPLG_ICE[as]}' ice can be used only with snippets%f"
    return 0
}

local __type="$1" __url="$2" __id_as="$3" __dir="$4" __hook="$5"

ZPLG_ICE[.track]=${ZPLG_ICE[as]}

if [[ ${ZPLG_ICE[as]} = track\|(command|program) ]] {
    ZPLG_ICE[as]=command
} elif [[ ${ZPLG_ICE[as]} = track\|completion ]] {
    ZPLG_ICE[as]=completion
} elif [[ ${ZPLG_ICE[as]} = track\|null ]] {
    ZPLG_ICE[as]=null
} else {
    unset 'ZPLG_ICE[as]'
}

if [[ -d $__dir && -z ${opts[(r)-u]} ]] {
    return 0
}

local -a match mbegin mend reply
local MATCH REPLY
integer MBEGIN MEND

(( ${+functions[-zplg-setup-plugin-dir]} )) || builtin source ${ZPLGM[BIN_DIR]}/zplugin-install.zsh

match=()
local dlpage=${__url%(#b)([^+])++*}
dlpage=$dlpage${match[1]}

if [[ -z ${ZPLG_ICE[dlink]} ]] {
    local plus=${(MS)__url%%[^+]++##} pattern_url=$dlpage
    plus=${plus#?+}
    while [[ -n $plus ]] {
        pattern_url=${pattern_url:h}
        plus=${plus%+}
    }
    local pattern_url=${pattern_url}/${__url##*++}
} else {
    local pattern_url=${ZPLG_ICE[dlink]}
}

local tmpfile="$(mktemp)"

-zplg-download-file-stdout $dlpage 1 >! $tmpfile || {
    -zplg-download-file-stdout $dlpage >! $tmpfile || {
        print -P "${ZPLGM[col-pre]}as-track annex: %F{160}ERROR: couldn't" \
            "fetch the download page (${ZPLGM[col-obj]}${dlpage//\%/%%}%F{160})%f"
        return 0
    }
}

pattern_url=${pattern_url//\%VERSION\%/[.,a-zA-Z0-9_-]\\+}

local -a list
list=( ${(@f)"$(command grep -io "href=.$pattern_url" $tmpfile)"} )

local selected=${list[1]#href=?}

if [[ -z $selected ]] {
    print -P -- "${ZPLGM[col-pre]}as-track annex: %F{160}Warning: couldn't match the URL at the download page%f"
    print -P -- "%F{160}(which is ${ZPLGM[col-obj]}${dlpage//\%/%%}%F{160}"\
"${${${__id_as:#$__url}:+\\nthe snippet is being identified as ${ZPLGM[col-obj2]}$__id_as%F\{160\}\)}:-\)}"
    return 9
}

if [[ $selected = /* ]] {
    local domain
    if [[ $dlpage = (#b)(#i)((http(s|)|ftp(s|)|ssh|scp)://[^/]##)(*) ]] {
        domain=${match[1]}
    } else {
        if [[ -z ${match[2]} ]] {
            print -P -- "${ZPLGM[col-pre]}as-track annex: %F{160}ERROR: the URL cannot be only a domain name%f"
            return 9
        } else {
            print -P -- "${ZPLGM[col-pre]}as-track annex: %F{160}ERROR: couldn't establish the domain name" \
                "(unsupported protocol? supported are: http(s),ftp(s),ssh,scp)%f"
            return 9
        }
    }
    local new_url=$domain$selected
} elif [[ $selected = (#i)(http(s|)|ftp(s|)|ssh|scp)://* ]] {
    local new_url=$selected
} else {
    local -a exts
    exts=(
        xhtml htmls html htm php php3 php4 phtml
        pl asp aspx ece js jsp jspx jhtml cfm py
        rb rhtml shtml cgi
    )
    if [[ $dlpage = *.(${(~j:|:)exts}) ]] {
        local new_url=${dlpage:h}/$selected
    } else {
        local new_url=$dlpage/$selected
    }
}

# Assign outer-scope parameters
url=$new_url

return 0

# vim:ft=zsh:tw=80:sw=4:sts=4:et
